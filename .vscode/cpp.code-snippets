{
    "a": {
        "prefix": "a",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "using namespace std;",
            "using namespace atcoder;",
            "using ll = long long;",
            "using mint = modint998244353;",
            "const ll INF = 2e+18;",
            "const ll MOD = 998244353;",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    cout << fixed << setprecision(15);",
            "    int T = 1;",
            "    // cin >> T;",
            "    while (T--) solve();",
            "}",
            ""
        ],
        "description": "a"
    },
    "priority_queue large": {
        "prefix": "pql",
        "body": [
            "priority_queue<$1> $0",
        ],
        "description": "priority_queue large"
    },
    "priority_queue small": {
        "prefix": "pqs",
        "body": [
            "priority_queue<$1, vector<$1>, greater<$1>> $0",
        ],
        "description": "priority_queue small"
    },
    "mod_pow": {
        "prefix": "mp",
        "body": [
            "template<typename T> T mod_pow(T a, ll n) {",
            "    if (n == 0) return 1;",
            "    T res = mod_pow(a, n/2);",
            "    if (n % 2 == 1) return res * res * a;",
            "    return res * res;",
            "}",
            "template<typename T> T mod_pow(T a, ll n, ll mod) {",
            "    if (n == 0) return 1;",
            "    T res = mod_pow(a, n/2, mod);",
            "    if (n % 2 == 1) return res * res % mod * a % mod;",
            "    return res * res % mod;",
            "}",
        ],
        "description": "mod_pow"
    },
    "matrix_pow": {
        "prefix": "mat",
        "body": [
            "template<typename T> vector<vector<T>> matrix_prod(vector<vector<T>> &A, vector<vector<T>> &B) {",
            "    int l = A.size();",
            "    int m = B.size();",
            "    int n = B[0].size();",
            "    vector<vector<T>> V(l, vector<T>(n, 0));",
            "    for (int i = 0; i < l; i++) {",
            "        for (int j = 0; j < n; j++) {",
            "            for (int k = 0; k < m; k++) {",
            "                V[i][j] += A[i][k] * B[k][j];",
            "            }",
            "        }",
            "    }",
            "    return V;",
            "}",
            "template<typename T> vector<T> matrix_prod(vector<vector<T>> &A, vector<T> &B) {",
            "    int l = A.size();",
            "    int m = B.size();",
            "    vector<T> V(l, 0);",
            "    for (int i = 0; i < l; i++) {",
            "        for (int k = 0; k < m; k++) {",
            "            V[i] += A[i][k] * B[k];",
            "        }",
            "    }",
            "    return V;",
            "}",
            "template<typename T> vector<vector<T>> matrix_pow(vector<vector<T>> &A, ll p) {",
            "    if (p == 1) return A;",
            "    int a_size = A.size();",
            "    if (p == 0) {",
            "        vector<vector<T>> V(a_size, vector<T>(a_size, 0));",
            "        for (int i = 0; i < a_size; i++) V[i][i] = 1;",
            "        return V;",
            "    }",
            "    vector<vector<T>> A_p_half = matrix_pow(A, p/2);",
            "    vector<vector<T>> V = matrix_prod(A_p_half, A_p_half);",
            "    if (p % 2 == 0) return V;",
            "    return matrix_prod(V, A);",
            "}"
        ],
        "description": "matrix pow"
    },
    "Union Find": {
        "prefix": "uf",
        "body": [
            "struct UnionFind {",
            "    vector<int> par, siz;",
            "",
            "    UnionFind(int n) : par(n, -1), siz(n, 1) {}",
            "",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            "",
            "    bool issame(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    bool unite(int x, int y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return false;",
            "        if (siz[x] < siz[y]) swap(x, y);",
            "        par[y] = x;",
            "        siz[x] += siz[y];",
            "        return true;",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "};"
        ],
    },
    "Fenwick": {
        "prefix": "f",
        "body": [
            "template<typename T> struct Fenwick {",
            "    int n;",
            "    vector<T> data;",
            "",
            "    Fenwick(int _n) {",
            "        n = _n + 1;",
            "        data.assign(n, 0);",
            "    }",
            "",
            "    void add(int i, T x) {",
            "        // Add x to a[i] (0-indexed).",
            "        for (int idx = i + 1; idx < n; idx += (idx & -idx)) {",
            "            data[idx] += x;",
            "        }",
            "    }",
            "",
            "    T _sum(int i) {",
            "        // compute sum of a[k] for k in [0, i)",
            "        T ans = 0;",
            "        for (int idx = i; idx > 0; idx -= (idx & -idx)) {",
            "            ans += data[idx];",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    T query(int a, int b) {",
            "        // compute sum of a[k] for k in [a, b)",
            "        return _sum(b) - _sum(a);",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "segment tree": {
        "prefix": "st",
        "body": [
            "template<typename T> struct SegmentTree {",
            "    int n;",
            "    vector<T> data;",
            "    T init_value = ;  // TODO: Set initial value of the data (e.g., INF if min, -INF if max, 0 if sum)",
            "",
            "    SegmentTree(int _n) {",
            "    n = 1;",
            "    while (n < _n) n *= 2;",
            "    data.assign(2*n-1, init_value);",
            "    }",
            "",
            "    T operation(T a, T b) {",
            "        // TODO: Set operating function (e.g., min, max, sum)",
            "        return ;",
            "    }",
            "",
            "    void update(int i, T a) {",
            "        // Update data[i] to a",
            "        i = n - 1 + i;",
            "        data[i] = operation(data[i], a);  // TODO: Set update operation if needed (e.g. data[i] = a )",
            "        while (i > 0) {",
            "            i = (i - 1) / 2;",
            "            data[i] = operation(data[i*2 + 1], data[i*2 + 2]);",
            "        }",
            "    }",
            "",
            "    T _sub_query(int i, int j, int k, int l, int r) {",
            "        if (r <= i || j <= l) return init_value;",
            "        if (i <= l && r <= j) return data[k];",
            "        T vl = _sub_query(i, j, 2*k + 1, l, (l + r)/2);",
            "        T vr = _sub_query(i, j, 2*k + 2, (l + r)/2, r);",
            "        return operation(vl, vr);",
            "    }",
            "",
            "    T query(int i, int j) {",
            "        // Return the answer in [i, j)",
            "        return _sub_query(i, j, 0, 0, n);",
            "    }",
            "};",
        ],
        "description": "Segment Tree"
    },
    "lazy segment tree": {
        "prefix": "lst",
        "body": [
            "template<typename X, typename M> struct LazySegmentTree {",
            "    int n;",
            "    vector<X> data;",
            "    vector<M> lazy;",
            "    X X_init =  // TODO: Set initial value of data X.",
            "    M M_init =  // TODO: Set initial value of act M.",
            "",
            "    LazySegmentTree(int n_) {",
            "        n = 1;",
            "        while (n < n_) n *= 2;",
            "        data.assign(2*n-1, X_init);",
            "        lazy.assign(2*n-1, M_init);",
            "    }",
            "",
            "    X X_operation(X a, X b) {",
            "        // TODO: Set operation on X x X. (e.g., min, max, +)",
            "        return",
            "    }",
            "",
            "    M M_operation(M a, M b) {",
            "        // TODO: Set operation on M x M.",
            "        return",
            "    }",
            "",
            "    X X_M_operation(X x, M m) {",
            "        // TODO: Set operation on X x M",
            "        return",
            "    }",
            "",
            "    void initialize(int i, X x) {",
            "        i = n - 1 + i;",
            "        data[i] = x;",
            "        while (i > 0) {",
            "            i = (i - 1) / 2;",
            "            data[i] = X_operation(data[i*2 + 1], data[i*2 + 2]);",
            "        }",
            "    }",
            "",
            "    void eval(int k) {",
            "        if (lazy[k] == M_init) return;",
            "        if (k < n - 1) {",
            "            lazy[k * 2 + 1] = M_operation(lazy[k * 2 + 1], lazy[k]);",
            "            lazy[k * 2 + 2] = M_operation(lazy[k * 2 + 2], lazy[k]);",
            "        }",
            "        data[k] = X_M_operation(data[k], lazy[k]);",
            "        lazy[k] = M_init;",
            "    }",
            "",
            "    void _update(int a, int b, M m, int k, int l, int r) {",
            "        eval(k);",
            "        if (a <= l && r <= b) {",
            "            lazy[k] = M_operation(lazy[k], m);",
            "            eval(k);",
            "        } else if (a < r && l < b) {",
            "            _update(a, b, m, k * 2 + 1, l, (l + r) / 2);",
            "            _update(a, b, m, k * 2 + 2, (l + r) / 2, r);",
            "            data[k] = X_operation(data[k * 2 + 1], data[k * 2 + 2]);",
            "        }",
            "    }",
            "",
            "    // Update data[i] with i in [a, b) by multiplying m in M.",
            "    void update(int a, int b, M m) {",
            "        _update(a, b, m, 0, 0, n);",
            "    }",
            "",
            "    X _sub_query(int a, int b, int k, int l, int r) {",
            "        eval(k);",
            "        if (r <= a || b <= l) {",
            "            return X_init;",
            "        } else if (a <= l && r <= b) {",
            "            return data[k];",
            "        } else {",
            "            X vl = _sub_query(a, b, k * 2 + 1, l, (l + r) / 2);",
            "            X vr = _sub_query(a, b, k * 2 + 2, (l + r) / 2, r);",
            "            return X_operation(vl, vr);",
            "        }",
            "    }",
            "",
            "    // Return the answer in [a, b)",
            "    X query(int a, int b) {",
            "        return _sub_query(a, b, 0, 0, n);",
            "    }",
            "};"
        ],
        "description": "Lazy Segment Tree"
    },
    "mod inv": {
        "prefix": "mi",
        "body": [
            "ll mod_inv(ll a, ll mod) {",
            "    // Check if a and mod are coprime.",
            "    ll b = mod, u = 1, v = 0;",
            "    while (b > 0) {",
            "        ll t = a / b;",
            "        a -= t * b;",
            "        swap(a, b);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "    u %= mod;",
            "    if (u < 0) u += mod;",
            "    return u;",
            "}"
        ],
        "description": "mod inv"
    },
    "max flow graph": {
        "prefix": "mfg",
        "body": [
            "template<typename T>",
            "struct MaxFlowGraph {",
            "    struct Edge {",
            "        int id;  // Edge id. If it is a reverse edge, set -1.",
            "        int to;  // Vertex id taht this edge is toward.",
            "        T cap;  // Capacity of this edge.",
            "        int rev; // Reverse edge's position in G[to].",
            "",
            "        Edge(int _id, int _to, T _cap, int _rev): id(_id), to(_to), cap(_cap), rev(_rev) {}",
            "    };",
            "",
            "    int N;  // Number of verteces.",
            "    int E;  // Number of edges (excluding the reverse edges for residual).",
            "    vector<vector<Edge>> G;",
            "    vector<int> dist;",
            "    vector<int> iter;",
            "",
            "    MaxFlowGraph(int n) {",
            "        N = n;",
            "        E = 0;",
            "        G.resize(N);",
            "    }",
            "",
            "    int add_edge(int from, int to, T cap) {",
            "        // Set edge from 'from' to 'to' with capacity 'cap'. Return the edge ID.",
            "        G[from].push_back(Edge(E, to, cap, G[to].size()));",
            "        G[to].push_back(Edge(-1, from, 0, G[from].size()-1));",
            "        E++;",
            "        return E-1;",
            "    }",
            "",
            "    void bfs(int s) {",
            "        // Compute min distance of each v from s by BFS.",
            "        dist.assign(N, -1);",
            "        dist[s] = 0;",
            "        queue<int> Q;",
            "        Q.push(s);",
            "        while (!Q.empty()) {",
            "            int v = Q.front();",
            "            Q.pop();",
            "            for (Edge &e : G[v]) {",
            "                if (e.cap > 0 && dist[e.to] < 0) {",
            "                    dist[e.to] = dist[v] + 1;",
            "                    Q.push(e.to);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    T dfs(int v, int t, T f) {",
            "        // Flow v to t with max flow f recursively by DFS.",
            "        if (v == t) return f;",
            "        for (int &i = iter[v]; i < (int)G[v].size(); i++) {",
            "            Edge &e = G[v][i];",
            "            if (e.cap > 0 && dist[v] < dist[e.to]) {",
            "                T d = dfs(e.to, t, min(f, e.cap));",
            "                if (d > 0) {",
            "                    e.cap -= d;",
            "                    G[e.to][e.rev].cap += d;",
            "                    return d;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    T max_flow(int s, int t) {",
            "        // Compute maximum flow via Dinic's algorithm. O(|E||V|^2) in worst case, but faster in many practical cases.",
            "        T flow = 0;",
            "        while (true) {",
            "            bfs(s);",
            "            if (dist[t] < 0) return flow;",
            "            iter.assign(N, 0);",
            "            T f = dfs(s, t, INF);",
            "            while (f > 0) {",
            "                flow += f;",
            "                f = dfs(s, t, INF);",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Dinic's Max Flow algorithm"
    },
    "min cost flow graph": {
        "prefix": "mcfg",
        "body": [
            "template<typename T>",
            "struct MinCostFlowGraph {",
            "    struct Edge {",
            "        int id;",
            "        int to;",
            "        T cap;",
            "        T cost;",
            "        int rev;",
            "",
            "        Edge(int _id, int _to, T _cap, T _cost, int _rev): id(_id), to(_to), cap(_cap), cost(_cost), rev(_rev) {}",
            "    };",
            "",
            "    T INF = 2e+9;  // TODO: update if needed.",
            "    int N;  // Number of verteces.",
            "    int E;  // Number of edges (excluding the reverse edges for residual).",
            "    vector<vector<Edge>> G;",
            "",
            "    MinCostFlowGraph(int n) {",
            "        N = n;",
            "        E = 0;",
            "        G.resize(N);",
            "    }",
            "",
            "    int add_edge(int from, int to, T cap, T cost) {",
            "        G[from].push_back(Edge(E, to, cap, cost, G[to].size()));",
            "        G[to].push_back(Edge(-1, from, 0, -cost, G[from].size()-1));",
            "        E++;",
            "        return E-1;",
            "    }",
            "",
            "    T min_cost_flow(int s, int t, T f) {",
            "        T res = 0;",
            "        vector<T> h(N, 0), dist(N, INF);",
            "        vector<int> prev_v(N, -1), prev_e(N, -1);",
            "        while (f > 0) {",
            "            // Update potential h[v] by Dijkstra.",
            "            priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> Q;",
            "            dist.assign(N, INF);",
            "            dist[s] = 0;",
            "            Q.push(make_pair(0, s));",
            "            while (!Q.empty()) {",
            "                pair<T, int> p = Q.top();",
            "                Q.pop();",
            "                int v = p.second;",
            "                if (dist[v] < p.first) continue;",
            "                for (int i = 0; i < (int)G[v].size(); i++) {",
            "                    Edge &e = G[v][i];",
            "                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
            "                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
            "                        prev_v[e.to] = v;",
            "                        prev_e[e.to] = i;",
            "                        Q.push(make_pair(dist[e.to], e.to));",
            "                    }",
            "                }",
            "            }",
            "            if (dist[t] == INF) return -1;",
            "            for (int v = 0; v < N; v++) h[v] += dist[v];",
            "",
            "            // Flow along the shortest path s-t.",
            "            T d = f;",
            "            for (int v = t; v != s; v = prev_v[v]) d = min(d, G[prev_v[v]][prev_e[v]].cap);",
            "            f -= d;",
            "            res += d * h[t];",
            "            for (int v = t; v != s; v = prev_v[v]) {",
            "                Edge &e = G[prev_v[v]][prev_e[v]];",
            "                e.cap -= d;",
            "                G[v][e.rev].cap += d;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Minimum Cost Flow algorithm"
    },
    "grid": {
        "prefix": "g",
        "body": [
            "int H, W;",
            "vector<int> dx{1, -1, 0, 0}, dy{0, 0, 1, -1};",
            "bool is_in(int x, int y) {return 0 <= x && x < H && 0 <= y && y < W;}",
            "int to_int(int x, int y) {return x*W + y;}",
            "pair<int,int> to_xy(int i) {return make_pair(i/W, i%W);}"
        ],
        "description": "Grid"
    },
    "rerooting_tree": {
        "prefix": "rt",
        "body": [
            "template <typename Cost, typename Data>",
            "struct RerootingTree {",
            "    template<typename C> struct Edge {",
            "        int to;",
            "        C cost;",
            "",
            "        Edge(int t, C c = 1): to(t), cost(c) {}",
            "    };",
            "    int N;",
            "    vector<vector<Edge<Cost>>> G;",
            "    vector<Data> ans;",
            "    vector<vector<Data>> dp;",
            "",
            "    /* Set variables and functions below depending on the problem! */",
            "    Data identity = 0;    // TODO: Set DP identity data.",
            "    Data leaf() {return 0;}    // TODO: Set DP data for leaf verteces.",
            "    Data merge(Data a, Data b) {return max(a, b);}    // TODO: Set merge function of two DP data.",
            "    Data apply(Data d_pc, int p, int c, Cost cost) {return d_pc + cost;}    // TODO: Set apply function. d_pc:data(dp[p][c]), p:parent, c:child, cost:edge_cost.",
            "    /* Up to here! */",
            "",
            "    RerootingTree(int n) {",
            "        N = n;",
            "        G.resize(n);",
            "    }",
            "",
            "    void add_edge(int u, int v, Cost c = 1) {",
            "        G[u].emplace_back(v, c);",
            "        G[v].emplace_back(u, c);",
            "    }",
            "",
            "    Data dfs1(int v, int par) {",
            "        int degree = G[v].size();",
            "        dp[v].assign(degree, identity);",
            "        Data dp_cum = identity;",
            "        bool updated = false;",
            "        for (int i = 0; i < degree; i++) {",
            "            Edge<Cost> &e = G[v][i];",
            "            if (e.to == par) continue;",
            "            dp[v][i] = dfs1(e.to, v);",
            "            dp_cum = merge(dp_cum, apply(dp[v][i], v, e.to, e.cost));",
            "            updated = true;",
            "        }",
            "        if (updated) return dp_cum;",
            "        else return leaf();",
            "    }",
            "",
            "    void dfs2(int v, Data val, int par) {",
            "        int degree = G[v].size();",
            "        vector<Data> dp_l(degree+1, identity), dp_r(degree+1, identity);",
            "        for (int i = 0; i < degree; i++) {",
            "            Edge<Cost> &e = G[v][i];",
            "            if (e.to == par) dp[v][i] = val;",
            "            dp_l[i+1] = merge(dp_l[i], apply(dp[v][i], v, e.to, e.cost));",
            "        }",
            "        for (int i = degree-1; i >= 0; i--) {",
            "            Edge<Cost> &e = G[v][i];",
            "            dp_r[i] = merge(dp_r[i+1], apply(dp[v][i], v, e.to, e.cost));",
            "        }",
            "        ans[v] = dp_l[degree];",
            "        for (int i = 0; i < degree; i++) {",
            "            Edge<Cost> &e = G[v][i];",
            "            if (e.to != par) dfs2(e.to, merge(dp_l[i], dp_r[i+1]), v);",
            "        }",
            "    }",
            "",
            "    void run() {",
            "        dp.resize(N);",
            "        ans.assign(N, identity);",
            "        dfs1(0, -1);",
            "        dfs2(0, identity, -1);",
            "    }",
            "};"
        ],
        "description": "Rerooting Tree DP"
    },
    "mo": {
        "prefix": "mo",
        "body": [
            "template <typename T>",
            "struct Mo {",
            "    struct Query {",
            "        int id, l, r, l_;",
            "        Query(int i, int l, int r, int b = 1): id(i), l(l), r(r) {l_ = l / b;}",
            "    };",
            "",
            "    int N, Q, B;",
            "    vector<Query> queries;",
            "    vector<T> ans;",
            "    int left=0, right=-1;",
            "",
            "    /* Update below! */",
            "    vector<T> state;    // TODO: Set state variables.",
            "    T tmp = 0;    // TODO: Set initial tmp answer.",
            "",
            "    void _add(int a) {",
            "        // TODO: Set add function used in query().",
            "    }",
            "    void _remove(int a) {",
            "        // TODO: Set remove function used in query().",
            "    }",
            "    void _query(Query &q) {",
            "        while (right < q.r) {",
            "            right++;",
            "            _add(A[right]);    // TODO: Update arg.",
            "        }",
            "        while (q.l < left) {",
            "            left--;",
            "            _add(A[left]);    // TODO: Update arg.",
            "        }",
            "        while (left < q.l) {",
            "            _remove(A[left]);    // TODO: Update arg.",
            "            left++;",
            "        }",
            "        while (q.r < right) {",
            "            _remove(A[right]);    // TODO: Update arg.",
            "            right--;",
            "        }",
            "        ans[q.id] = tmp;",
            "    }",
            "    Mo(int n, int q): N(n), Q(q) {",
            "        B = max<int>(1, 1.0 * N / max<double>(1.0, sqrt(Q * 2.0 / 3.0)));",
            "        queries.assign(Q, {0, 0, 0});",
            "        ans.assign(Q, 0);",
            "        state.assign(N, 0);  // TODO: Set state variable.",
            "    }",
            "    /* Up to here! */",
            "",
            "    void add_query(int i, int l, int r) {",
            "        // Add i'th query for [l, r] . (REMARK: closed interval!)",
            "        queries[i] = Query(i, l, r, B);",
            "    }",
            "",
            "    void run() {",
            "        sort(queries.begin(), queries.end(), [](Query &q1, Query &q2){",
            "            if (q1.l_ != q2.l_) return q1.l_ < q2.l_;",
            "            return q1.r < q2.r;",
            "        });",
            "        for (Query &q : queries) _query(q);",
            "    }",
            "};"
        ],
        "description": "Mo's algorithm"
    },
    "lowlink": {
        "prefix": "lowlink",
        "body": [
            "struct LowLink {",
            "    int N;",
            "    vector<vector<int>> &G;",
            "    vector<bool> reached;",
            "    vector<int> ord, low;",
            "    vector<int> num_change_connections;  // その頂点を除くことによる連結成分数の変化",
            "    vector<pair<int,int>> bridges;  // 橋のvector（その辺を除くと連結成分が増える辺）",
            "",
            "    LowLink(vector<vector<int>> &G_): G(G_) {",
            "        N = G.size();",
            "        reached.assign(N, false);",
            "        ord.assign(N, 0);",
            "        low.assign(N, 0);",
            "        num_change_connections.assign(N, 0);",
            "        int k = 0;",
            "        for (int u = 0; u < N; u++) {",
            "            if (!reached[u]) k = dfs(u, k, -1);",
            "        }",
            "    }",
            "",
            "    int dfs(int u, int k, int p) {",
            "        if (p == -1) num_change_connections[u] = -1;",
            "        reached[u] = true;",
            "        ord[u] = k;",
            "        k++;",
            "        low[u] = ord[u];",
            "        int num_children = 0;",
            "        for (int v : G[u]) {",
            "            if (!reached[v]) {",
            "                num_children++;",
            "                k = dfs(v, k, u);",
            "                low[u] = min(low[u], low[v]);",
            "                if (ord[u] <= low[v]) num_change_connections[u]++;",
            "                if (ord[u] < low[v]) bridges.push_back(make_pair(u, v));",
            "            } else {",
            "                if (v != p) low[u] = min(low[u], ord[v]);",
            "            }",
            "        }",
            "        return k;",
            "    }",
            "};"
        ],
        "description": "LowLink"
    },
    "erasable_priority_queue": {
        "prefix": "epq",
        "body": [
            "template<typename T> struct erasable_priority_queue {",
            "    priority_queue<T> Q, R;",
            "",
            "    void push(T x) {",
            "        Q.push(x);",
            "    }",
            "",
            "    void erase(T x) {",
            "        R.push(x);",
            "    }",
            "",
            "    T top() {",
            "        T x = Q.top();",
            "        while (!R.empty() && R.top() == x) {",
            "            Q.pop();",
            "            R.pop();",
            "            x = Q.top();",
            "        }",
            "        return x;",
            "    }",
            "",
            "    int size() {",
            "        return Q.size() - R.size();",
            "    }",
            "",
            "    bool empty() {",
            "        return Q.size() == R.size();",
            "    }",
            "};"
        ],
        "description": "Erasable Priority Queue"
    },
    "convex_hull": {
        "prefix": "ch",
        "body": [
            "template<typename T> vector<pair<T,T>> convex_hull(vector<pair<T,T>> P) {",
            "    // Return ConvecHull of the set of points P via Graham's scan algorithm",
            "    auto pair_minus = [](pair<T,T> p, pair<T,T> q) -> pair<T,T> {return make_pair(p.first - q.first, p.second - q.second);};",
            "    auto cross_product = [](pair<T,T> p, pair<T, T> q) -> T {return p.first*q.second - p.second*q.first;};",
            "    sort(P.begin(), P.end());",
            "    vector<pair<T,T>> Q_over={P[0],P[1]}, Q_under={P[0],P[1]};",
            "    for (int i = 2; i < (int)P.size(); i++) {",
            "        while ((int)Q_over.size() >= 2 && cross_product(pair_minus(P[i], Q_over.back()), pair_minus(Q_over[(int)Q_over.size()-2], Q_over.back())) >= 0) Q_over.pop_back();",
            "        Q_over.push_back(P[i]);",
            "        while ((int)Q_under.size() >= 2 && cross_product(pair_minus(P[i], Q_under.back()), pair_minus(Q_under[(int)Q_under.size()-2], Q_under.back())) <= 0) Q_under.pop_back();",
            "        Q_under.push_back(P[i]);",
            "    }",
            "    vector<pair<T,T>> Q = Q_under;",
            "    for (int i = Q_over.size()-2; i > 0; i--) Q.push_back(Q_over[i]);",
            "    return Q;",
            "}",
            ""
        ],
        "description": "Convex Hull via Graham's scan"
    },
    "trie": {
        "prefix": "t",
        "body": [
            "struct Trie {",
            "    struct Node {",
            "        int idx;",
            "        vector<int> next;",
            "        int cnt;",
            "        int last;",
            "        Node(int i) {",
            "            idx = i;",
            "            next.assign(26, -1);",
            "            cnt = 0;",
            "            last = 0;",
            "        }",
            "    };",
            "",
            "    vector<Node> Nodes;",
            "    Trie() {",
            "        Nodes.push_back(Node(0));",
            "    }",
            "",
            "    void insert(string s) {",
            "        int now = 0;",
            "        Nodes[now].cnt++;",
            "        for (int i = 0; i < (int)s.size(); i++) {",
            "            if (Nodes[now].next[s[i]-'a'] == -1) {",
            "                Nodes[now].next[s[i]-'a'] = Nodes.size();",
            "                Nodes.push_back(Node(Nodes.size()));",
            "                now = Nodes.back().idx;",
            "            } else {",
            "                now = Nodes[now].next[s[i]-'a'];",
            "            }",
            "            Nodes[now].cnt++;",
            "        }",
            "        Nodes[now].last++;",
            "    }",
            "",
            "    int search(string s) {",
            "        int now = 0;",
            "        for (int i = 0; i < (int)s.size(); i++) {",
            "            if (Nodes[now].next[s[i]-'a'] == -1) return 0;",
            "            now =  Nodes[now].next[s[i]-'a'];",
            "        }",
            "        return Nodes[now].last;",
            "    }",
            "",
            "    int prefix(string s) {",
            "        int now = 0;",
            "        for (int i = 0; i < (int)s.size(); i++) {",
            "            if (Nodes[now].next[s[i]-'a'] == -1) return 0;",
            "            now =  Nodes[now].next[s[i]-'a'];",
            "        }",
            "        return Nodes[now].cnt;",
            "    }",
            "};",
            ""
        ],
        "description": "trie (prefix) tree"
    },
    "rolling_hash": {
        "prefix": "rh",
        "body": [
            "ll base, MOD;",
            "vector<ll> base_power(1e+7, 1);",
            "void preprocessing() {",
            "    // TODO: Run this function before using RollingHash.",
            "    auto is_prime = [](ll x) -> bool {for (ll i = 2; i*i <= x; i++) if (x % i == 0) return false; return true;};",
            "    random_device seed_gen;",
            "    mt19937_64 engine(seed_gen());",
            "    uniform_int_distribution<> dist_mod((ll)1e+9, (ll)2e+9);",
            "    do {MOD = dist_mod(engine);} while(!is_prime(MOD));",
            "    uniform_int_distribution<> dist_base(100, 10000);",
            "    base = dist_base(engine);",
            "    for (int i = 1; i < (ll)1e+7; i++) base_power[i] = base_power[i-1]*base%MOD;",
            "}",
            "struct RollingHash{",
            "    char first_character = 'a';  // TODO: Change first character if needed.",
            "    ll n = 0;",
            "    vector<ll> hashes;",
            "    RollingHash() {};",
            "    RollingHash(string &s) {",
            "        n = s.size();",
            "        hashes.assign(n+1, 0);",
            "        for (int i = n-1; i >= 0; i--) hashes[i] = hashes[i+1]*base%MOD + (ll)(s[i] - first_character + 1);",
            "    }",
            "    ll hash(int l) {",
            "        if (!(0 <= l && l <= n)) return -1;",
            "        return hashes[l];",
            "    }",
            "    ll hash(int l, int r) {",
            "        if (!(0 <= l && l <= r && r <= n)) return -1;",
            "        return (hashes[l] - hashes[r]*base_power[r-l]%MOD + MOD)%MOD;",
            "    }",
            "};"
        ],
        "description": "rolling hash"
    },
    "disjoint_sparse_table": {
        "prefix": "dst",
        "body": [
            "template<typename T> struct DisjointSparseTable {",
            "    T identity_element = (T)1e+9;    // TODO: Change identity_element if needed. e.g.) 0, 1, INF, etc.",
            "    T f(T l, T r) {return min(l, r);}    // TODO: Change the function f if needed. e.g) min, max, etc.",
            "    vector<vector<T>> st;",
            "    vector<int> lookup;",
            "",
            "    DisjointSparseTable(const vector<T> &v) {",
            "        int b = 0;",
            "        while ((1 << b) <= (int)v.size()) ++b;",
            "        st.resize(b, vector<T>(v.size(), identity_element));",
            "        for (int i = 0; i < (int)v.size(); i++) st[0][i] = v[i];",
            "        for (int i = 1; i < b; i++) {",
            "        int shift = 1 << i;",
            "        for (int j = 0; j < (int)v.size(); j += (shift << 1)) {",
            "                int t = min(j + shift, (int)v.size());",
            "                st[i][t - 1] = v[t - 1];",
            "                for (int k = t - 2; k >= j; k--) st[i][k] = f(v[k], st[i][k + 1]);",
            "                if ((int)v.size() <= t) break;",
            "                st[i][t] = v[t];",
            "                int r = min(t + shift, (int)v.size());",
            "                for (int k = t + 1; k < r; k++) st[i][k] = f(st[i][k - 1], v[k]);",
            "            }",
            "        }",
            "        lookup.resize(1 << b);",
            "        for (int i = 2; i < (int)lookup.size(); i++) {",
            "            lookup[i] = lookup[i >> 1] + 1;",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        // Return the answer in the interval [l, r).",
            "        if (l >= --r) return st[0][l];",
            "        int p = lookup[l ^ r];",
            "        return f(st[p][l], st[p][r]);",
            "    }",
            "};"
        ],
        "description": "disjoint sparse table"
    },
    "cumulative_sum": {
        "prefix": "cs",
        "body": [
            "template<typename T> struct CumulativeSum {",
            "    int N;",
            "    vector<T> data;",
            "",
            "    CumulativeSum(vector<T> &A) {",
            "        N = A.size();",
            "        data.assign(N+1, 0);",
            "        for (int i = 0; i < N; i++) data[i+1] = data[i] + A[i];",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        // Return Sum of [l, r)",
            "        return data[r]-data[l];",
            "    }",
            "};"
        ],
        "description": "cumulative sum"
    }
}
