{
	"a": {
		"prefix": "a",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"    $0",
			"}",
			"",
		],
		"description": ""
	},
	"c": {
		"prefix": "c",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
    		"    int T;",
			"    cin >> T;",
    		"    for (int t = 0; t < T; t++) solve();",
			"}",
			"",
		],
		"description": ""
	},
	"acl": {
		"prefix": "at",
		"body": [
			"#include <atcoder/all>$0",
		],
		"description": "AtCoder Library"
	},
	"long long": {
		"prefix": "ll",
		"body": [
			"typedef long long ll;",
		],
		"description": "long long"
	},
	"unsigned long long": {
		"prefix": "ull",
		"body": [
			"typedef unsigned long long ull;$0",
		],
		"description": "unsigned long long"
	},
	"for": {
		"prefix": "f",
		"body": [
			"for (int i$1 = 0$2; i$3 < N$4; i++$5) $0",
		],
		"description": "for"
	},
	"cin": {
		"prefix": "ci",
		"body": [
			"cin >> $0",
		],
		"description": "cin"
	},
	"cout": {
		"prefix": "co",
		"body": [
			"cout << $1 << endl$0;",
		],
		"description": "cout"
	},
	"vector": {
		"prefix": "v",
		"body": [
			"vector<$1> $0",
		],
		"description": "vector"
	},
	"pair": {
		"prefix": "p",
		"body": [
			"pair<$1, $2> $0",
		],
		"description": "pair"
	},
	"priority_queue small": {
		"prefix": "pqs",
		"body": [
			"priority_queue<$1, vector<$1>, greater<$1>> $0",
		],
		"description": "priority_queue small"
	},
	"priority_queue large": {
		"prefix": "pql",
		"body": [
			"priority_queue<$1> $0",
		],
		"description": "priority_queue large"
	},
	"all": {
		"prefix": "al",
		"body": [
			"$1.begin(), $1.end()",
		],
		"description": "all"
	},
	"sort": {
		"prefix": "so",
		"body": [
			"sort($1.begin(), $1.end());",
		],
		"description": "sort"
	},
	"mod_pow": {
		"prefix": "mp",
		"body": [
			"ll mod_pow(ll a, ll n) {",
		    "    if (n == 0) return 1;",
			"    ll res = mod_pow(a, n/2);",
			"    if (n % 2 == 1) return res * res % MOD * a % MOD;",
			"    else return res * res % MOD;",
			"}$0",
		],
		"description": "mod_pow"
	},
	"MOD": {
		"prefix": "MOD",
		"body": [
			"const ll MOD = 998244353LL;$0",
		],
		"description": "MOD"
	},
	"lower_bound": {
		"prefix": "lo",
		"body": [
			"lower_bound($1.begin(), $1.end(), $2);$0",
		],
		"description": "lower_bound"
	},
	"upper_bound": {
		"prefix": "up",
		"body": [
			"upper_bound($1.begin(), $1.end(), $2);$0",
		],
		"description": "upper_bound"
	},
	"union_find": {
		"prefix": "uf",
		"body": [
			"struct UnionFind {",
			"    vector<int> par, siz;",
			"",
			"    UnionFind(int n) : par(n, -1), siz(n, 1) {}",
			"",
			"    int root(int x) {",
			"        if (par[x] == -1) return x;",
			"        else return par[x] = root(par[x]);",
			"    }",
			"",
			"    bool issame(int x, int y) {",
			"        return root(x) == root(y);",
			"    }",
			"",
			"    bool unite(int x, int y) {",
			"        x = root(x);",
			"        y = root(y);",
			"        if (x == y) return false;",
			"        if (siz[x] < siz[y]) swap(x, y);",
			"        par[y] = x;",
			"        siz[x] += siz[y];",
			"        return true;",
			"    }",
			"",
			"    int size(int x) {",
			"        return siz[root(x)];",
			"    }",
			"};"
		],
	},
	"bit": {
		"prefix": "bit",
		"body": [
			"struct BIT {",
			"    int n;",
			"    vector<ll> data;",
			"",
			"    BIT(int _n) {",
			"        n = _n + 1;",
			"        data.assign(n, 0);",
			"    }",
			"",
			"    void add(int i, ll x) {",
			"        // Add x to a[i] (0-indexed).",
			"        for (int idx = i + 1; idx < n; idx += (idx & -idx)) {",
			"            data[idx] += x;",
			"        }",
			"    }",
			"",
			"    ll sum(int i) {",
			"        // compute sum of a[i] with i in [0, i)",
			"        ll ans = 0;",
			"        for (int idx = i; idx > 0; idx -= (idx & -idx)) {",
			"            ans += data[idx];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    ll sum(int a, int b) {",
			"        // compute sum of a[i] with i in [a, b)",
			"        return sum(b) - sum(a);",
			"    }",
			"};"
		]
	},
	"st": {
		"prefix": "st",
		"body": [
			"template<typename T>",
			"struct SegmentTree {",
			"	int n;",
			"	vector<T> data;",
			"	T init_value = $1;  // TODO: Set initial value of the data (e.g., INF if min, -INF if max, 0 if sum)",
			"",
			"	SegmentTree(int _n) {",
			"		n = 1;",
			"		while (n < _n) n *= 2;",
			"		data.assign(2*n-1, init_value);",
			"	}",
			"",
			"	T operation(T a, T b) {",
			"		// TODO: Set operating function (e.g., min, max, sum)",
			"		return $2;",
			"	}",
			"",
			"	// Update data[i] to a.",
			"	void update(int i, T a) {",
			"		i = n - 1 + i;",
			"		data[i] = operation(data[i], a);  // TODO: Set update operation if needed (e.g. data[i] = a )",
			"		while (i > 0) {",
			"			i = (i - 1) / 2;",
			"			data[i] = operation(data[i*2 + 1], data[i*2 + 2]);",
			"		}",
			"	}",
			"",
			"	T _sub_query(int i, int j, int k, int l, int r) {",
			"		if (r <= i || j <= l) return init_value;",
			"		if (i <= l && r <= j) return data[k];",
			"		ll vl = _sub_query(i, j, 2*k + 1, l, (l + r)/2);",
			"		ll vr = _sub_query(i, j, 2*k + 2, (l + r)/2, r);",
			"		return operation(vl, vr);",
			"	}",
			"",
			"	// Return the answer in [i, j)",
			"	T query(int i, int j) {",
			"		return _sub_query(i, j, 0, 0, n);",
			"	}",
			"};",
		],
		"description": "Segment Tree"
	},
	"lst": {
		"prefix": "lst",
		"body": [
			"template<typename X, typename M>",
			"struct LazySegmentTree {",
			"	int n;",
			"	vector<X> data;",
			"	vector<M> lazy;",
			"	X X_init = $1; // TODO: Set initial value of data X.",
			"	M M_init = $2; // TODO: Set initial value of act M.",
			"",
			"	LazySegmentTree(int n_) {",
			"		n = 1;",
			"		while (n < n_) n *= 2;",
			"		data.assign(2*n-1, X_init);",
			"		lazy.assign(2*n-1, M_init);",
			"	}",
			"",
			"	X X_operation(X a, X b) {",
			"		// TODO: Set operation on X x X. (e.g., min, max, +)",
			"		return min(a, b)$3;",
			"	}",
			"",
			"	M M_operation(M a, M b) {",
			"		// TODO: Set operation on M x M.",
			"		if (b == M_init) return a;",
			"		else return b$4;",
			"	}",
			"",
			"	X X_M_operation(X x, M m) {",
			"		// TODO: Set operation on X x M",
			"		if (m == M_init) return x;",
			"		return m$5;",
			"	}",
			"",
			"	void eval(int k) {",
			"		if (lazy[k] == M_init) return;",
			"		if (k < n - 1) {",
			"			lazy[k * 2 + 1] = M_operation(lazy[k * 2 + 1], lazy[k]);",
			"			lazy[k * 2 + 2] = M_operation(lazy[k * 2 + 2], lazy[k]);",
			"		}",
			"		data[k] = X_M_operation(data[k], lazy[k]);",
			"		lazy[k] = M_init;",
			"	}",
			"",
			"	void _update(int a, int b, M m, int k, int l, int r) {",
			"		eval(k);",
			"		if (a <= l && r <= b) {",
			"			lazy[k] = M_operation(lazy[k], m);",
			"			eval(k);",
			"		} else if (a < r && l < b) {",
			"			_update(a, b, m, k * 2 + 1, l, (l + r) / 2);",
			"			_update(a, b, m, k * 2 + 2, (l + r) / 2, r);",
			"			data[k] = X_operation(data[k * 2 + 1], data[k * 2 + 2]);",
			"		}",
			"	}",
			"",
			"	// Update data[i] with i in [a, b) by multiplying m in M.",
			"	void update(int a, int b, M m) {",
			"		_update(a, b, m, 0, 0, n);",
			"	}",
			"",
			"	X _sub_query(int a, int b, int k, int l, int r) {",
			"		eval(k);",
			"		if (r <= a || b <= l) {",
			"			return X_init;",
			"		} else if (a <= l && r <= b) {",
			"			return data[k];",
			"		} else {",
			"			X vl = _sub_query(a, b, k * 2 + 1, l, (l + r) / 2);",
			"			X vr = _sub_query(a, b, k * 2 + 2, (l + r) / 2, r);",
			"			return X_operation(vl, vr);",
			"		}",
			"	}",
			"",
			"	// Return the answer in [a, b)",
			"	X query(int a, int b) {",
			"		return _sub_query(a, b, 0, 0, n);",
			"	}",
			"};"
		],
		"description": "Lazy Segment Tree"
	},
	"mi": {
		"prefix": "mi",
		"body": [
			"ll modinv(ll a) {",
			"	// Check if a and MOD are coprime.",
			"	ll b = MOD, u = 1, v = 0;",
			"	while (b > 0) {",
			"		ll t = a / b;",
			"		a -= t * b;",
			"		swap(a, b);",
			"		u -= t * v;",
			"		swap(u, v);",
			"	}",
			"	u %= MOD;",
			"	if (u < 0) u += MOD;",
			"	return u;",
			"}"
		],
		"description": "ModInt"
	}
}
