{
	"atcoder": {
		"prefix": "a",
		"body": [
			"$0#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"}",
			"",
		],
		"description": ""
	},
	"codeforces": {
		"prefix": "c",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
    		"    int T;",
			"    cin >> T;",
    		"    for (int t = 0; t < T; t++) solve();",
			"}",
			"",
		],
		"description": ""
	},
	"acl": {
		"prefix": "at",
		"body": [
			"#include <atcoder/all>$0",
		],
		"description": "AtCoder Library"
	},
	"long long": {
		"prefix": "ll",
		"body": [
			"typedef long long ll;",
		],
		"description": "long long"
	},
	"unsigned long long": {
		"prefix": "ull",
		"body": [
			"typedef unsigned long long ull;$0",
		],
		"description": "unsigned long long"
	},
	"for": {
		"prefix": "f",
		"body": [
			"for (int i$1 = 0$2; i$3 < N$4; i++$5) $0",
		],
		"description": "for"
	},
	"cin": {
		"prefix": "ci",
		"body": [
			"cin >> $0",
		],
		"description": "cin"
	},
	"cout": {
		"prefix": "co",
		"body": [
			"cout << $1 << endl$0;",
		],
		"description": "cout"
	},
	"vector": {
		"prefix": "v",
		"body": [
			"vector<$1> $0",
		],
		"description": "vector"
	},
	"pair": {
		"prefix": "p",
		"body": [
			"pair<$1, $2> $0",
		],
		"description": "pair"
	},
	"priority_queue small": {
		"prefix": "pqs",
		"body": [
			"priority_queue<$1, vector<$1>, greater<$1>> $0",
		],
		"description": "priority_queue small"
	},
	"priority_queue large": {
		"prefix": "pql",
		"body": [
			"priority_queue<$1> $0",
		],
		"description": "priority_queue large"
	},
	"all": {
		"prefix": "al",
		"body": [
			"$1.begin(), $1.end()",
		],
		"description": "all"
	},
	"sort": {
		"prefix": "so",
		"body": [
			"sort($1.begin(), $1.end());",
		],
		"description": "sort"
	},
	"mod_pow": {
		"prefix": "mp",
		"body": [
			"ll mod_pow(ll a, ll n) {",
		    "    if (n == 0) return 1;",
			"    ll res = mod_pow(a, n/2);",
			"    if (n % 2 == 1) return res * res % MOD * a % MOD;",
			"    else return res * res % MOD;",
			"}$0",
		],
		"description": "mod_pow"
	},
	"MOD": {
		"prefix": "MOD",
		"body": [
			"const ll MOD = 998244353LL;$0",
		],
		"description": "MOD"
	},
	"lower_bound": {
		"prefix": "lo",
		"body": [
			"lower_bound($1.begin(), $1.end(), $2);$0",
		],
		"description": "lower_bound"
	},
	"upper_bound": {
		"prefix": "up",
		"body": [
			"upper_bound($1.begin(), $1.end(), $2);$0",
		],
		"description": "upper_bound"
	},
	"union_find": {
		"prefix": "uf",
		"body": [
			"struct UnionFind {",
			"    vector<int> par, siz;",
			"",
			"    UnionFind(int n) : par(n, -1), siz(n, 1) {}",
			"",
			"    int root(int x) {",
			"        if (par[x] == -1) return x;",
			"        else return par[x] = root(par[x]);",
			"    }",
			"",
			"    bool issame(int x, int y) {",
			"        return root(x) == root(y);",
			"    }",
			"",
			"    bool unite(int x, int y) {",
			"        x = root(x);",
			"        y = root(y);",
			"        if (x == y) return false;",
			"        if (siz[x] < siz[y]) swap(x, y);",
			"        par[y] = x;",
			"        siz[x] += siz[y];",
			"        return true;",
			"    }",
			"",
			"    int size(int x) {",
			"        return siz[root(x)];",
			"    }",
			"};"
		],
	},
	"bit": {
		"prefix": "bit",
		"body": [
			"struct BIT {",
			"    int n;",
			"    vector<ll> data;",
			"",
			"    BIT(int _n) {",
			"        n = _n + 1;",
			"        data.assign(n, 0);",
			"    }",
			"",
			"    void add(int i, ll x) {",
			"        // Add x to a[i] (0-indexed).",
			"        for (int idx = i + 1; idx < n; idx += (idx & -idx)) {",
			"            data[idx] += x;",
			"        }",
			"    }",
			"",
			"    ll sum(int i) {",
			"        // compute sum of a[i] with i in [0, i)",
			"        ll ans = 0;",
			"        for (int idx = i; idx > 0; idx -= (idx & -idx)) {",
			"            ans += data[idx];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    ll sum(int a, int b) {",
			"        // compute sum of a[i] with i in [a, b)",
			"        return sum(b) - sum(a);",
			"    }",
			"};"
		]
	},
	"segment tree": {
		"prefix": "st",
		"body": [
			"template<typename T>",
			"struct SegmentTree {",
			"	int n;",
			"	vector<T> data;",
			"	T init_value = $1;  // TODO: Set initial value of the data (e.g., INF if min, -INF if max, 0 if sum)",
			"",
			"	SegmentTree(int _n) {",
			"		n = 1;",
			"		while (n < _n) n *= 2;",
			"		data.assign(2*n-1, init_value);",
			"	}",
			"",
			"	T operation(T a, T b) {",
			"		// TODO: Set operating function (e.g., min, max, sum)",
			"		return $2;",
			"	}",
			"",
			"	// Update data[i] to a.",
			"	void update(int i, T a) {",
			"		i = n - 1 + i;",
			"		data[i] = operation(data[i], a);  // TODO: Set update operation if needed (e.g. data[i] = a )",
			"		while (i > 0) {",
			"			i = (i - 1) / 2;",
			"			data[i] = operation(data[i*2 + 1], data[i*2 + 2]);",
			"		}",
			"	}",
			"",
			"	T _sub_query(int i, int j, int k, int l, int r) {",
			"		if (r <= i || j <= l) return init_value;",
			"		if (i <= l && r <= j) return data[k];",
			"		ll vl = _sub_query(i, j, 2*k + 1, l, (l + r)/2);",
			"		ll vr = _sub_query(i, j, 2*k + 2, (l + r)/2, r);",
			"		return operation(vl, vr);",
			"	}",
			"",
			"	// Return the answer in [i, j)",
			"	T query(int i, int j) {",
			"		return _sub_query(i, j, 0, 0, n);",
			"	}",
			"};",
		],
		"description": "Segment Tree"
	},
	"lazy segment tree": {
		"prefix": "lst",
		"body": [
			"template<typename X, typename M>",
			"struct LazySegmentTree {",
			"	int n;",
			"	vector<X> data;",
			"	vector<M> lazy;",
			"	X X_init = $1; // TODO: Set initial value of data X.",
			"	M M_init = $2; // TODO: Set initial value of act M.",
			"",
			"	LazySegmentTree(int n_) {",
			"		n = 1;",
			"		while (n < n_) n *= 2;",
			"		data.assign(2*n-1, X_init);",
			"		lazy.assign(2*n-1, M_init);",
			"	}",
			"",
			"	X X_operation(X a, X b) {",
			"		// TODO: Set operation on X x X. (e.g., min, max, +)",
			"		return min(a, b)$3;",
			"	}",
			"",
			"	M M_operation(M a, M b) {",
			"		// TODO: Set operation on M x M.",
			"		if (b == M_init) return a;",
			"		else return b$4;",
			"	}",
			"",
			"	X X_M_operation(X x, M m) {",
			"		// TODO: Set operation on X x M",
			"		if (m == M_init) return x;",
			"		return m$5;",
			"	}",
			"",
			"	void eval(int k) {",
			"		if (lazy[k] == M_init) return;",
			"		if (k < n - 1) {",
			"			lazy[k * 2 + 1] = M_operation(lazy[k * 2 + 1], lazy[k]);",
			"			lazy[k * 2 + 2] = M_operation(lazy[k * 2 + 2], lazy[k]);",
			"		}",
			"		data[k] = X_M_operation(data[k], lazy[k]);",
			"		lazy[k] = M_init;",
			"	}",
			"",
			"	void _update(int a, int b, M m, int k, int l, int r) {",
			"		eval(k);",
			"		if (a <= l && r <= b) {",
			"			lazy[k] = M_operation(lazy[k], m);",
			"			eval(k);",
			"		} else if (a < r && l < b) {",
			"			_update(a, b, m, k * 2 + 1, l, (l + r) / 2);",
			"			_update(a, b, m, k * 2 + 2, (l + r) / 2, r);",
			"			data[k] = X_operation(data[k * 2 + 1], data[k * 2 + 2]);",
			"		}",
			"	}",
			"",
			"	// Update data[i] with i in [a, b) by multiplying m in M.",
			"	void update(int a, int b, M m) {",
			"		_update(a, b, m, 0, 0, n);",
			"	}",
			"",
			"	X _sub_query(int a, int b, int k, int l, int r) {",
			"		eval(k);",
			"		if (r <= a || b <= l) {",
			"			return X_init;",
			"		} else if (a <= l && r <= b) {",
			"			return data[k];",
			"		} else {",
			"			X vl = _sub_query(a, b, k * 2 + 1, l, (l + r) / 2);",
			"			X vr = _sub_query(a, b, k * 2 + 2, (l + r) / 2, r);",
			"			return X_operation(vl, vr);",
			"		}",
			"	}",
			"",
			"	// Return the answer in [a, b)",
			"	X query(int a, int b) {",
			"		return _sub_query(a, b, 0, 0, n);",
			"	}",
			"};"
		],
		"description": "Lazy Segment Tree"
	},
	"mod inv": {
		"prefix": "mi",
		"body": [
			"ll modinv(ll a) {",
			"	// Check if a and MOD are coprime.",
			"	ll b = MOD, u = 1, v = 0;",
			"	while (b > 0) {",
			"		ll t = a / b;",
			"		a -= t * b;",
			"		swap(a, b);",
			"		u -= t * v;",
			"		swap(u, v);",
			"	}",
			"	u %= MOD;",
			"	if (u < 0) u += MOD;",
			"	return u;",
			"}"
		],
		"description": "ModInt"
	},
	"max flow graph": {
		"prefix": "mfg",
		"body": [
			"template<typename T>",
			"struct MaxFlowGraph {",
			"	struct Edge {",
			"		int id;  // Edge id. If it is a reverse edge, set -1.",
			"		int to;  // Vertex id taht this edge is toward.",
			"		T cap;  // Capacity of this edge.",
			"		int rev; // Reverse edge's position in G[to].",
			"",
			"		Edge(int _id, int _to, T _cap, int _rev): id(_id), to(_to), cap(_cap), rev(_rev) {}",
			"	};",
			"",
			"	T INF = 2e+9; // TODO: Update if needed.",
			"	int N;  // Number of verteces.",
			"	int E;  // Number of edges (excluding the reverse edges for residual).",
			"	vector<vector<Edge>> G;",
			"	vector<int> dist;",
			"	vector<int> iter;",
			"",
			"	MaxFlowGraph(int n) {",
			"		N = n;",
			"		E = 0;",
			"		G.resize(N);",
			"	}",
			"",
			"	int add_edge(int from, int to, T cap) {",
			"		// Set edge from 'from' to 'to' with capacity 'cap'. Return the edge ID.",
			"		G[from].push_back(Edge(E, to, cap, G[to].size()));",
			"		G[to].push_back(Edge(-1, from, 0, G[from].size()-1));",
			"		E++;",
			"		return E-1;",
			"	}",
			"",
			"	void bfs(int s) {",
			"		// Compute min distance of each v from s by BFS.",
			"		dist.assign(N, -1);",
			"		dist[s] = 0;",
			"		queue<int> Q;",
			"		Q.push(s);",
			"		while (!Q.empty()) {",
			"			int v = Q.front();",
			"			Q.pop();",
			"			for (Edge &e : G[v]) {",
			"				if (e.cap > 0 && dist[e.to] < 0) {",
			"					dist[e.to] = dist[v] + 1;",
			"					Q.push(e.to);",
			"				}",
			"			}",
			"		}",
			"	}",
			"",
			"	T dfs(int v, int t, T f) {",
			"		// Flow v to t with max flow f recursively by DFS.",
			"		if (v == t) return f;",
			"		for (int &i = iter[v]; i < (int)G[v].size(); i++) {",
			"			Edge &e = G[v][i];",
			"			if (e.cap > 0 && dist[v] < dist[e.to]) {",
			"				T d = dfs(e.to, t, min(f, e.cap));",
			"				if (d > 0) {",
			"					e.cap -= d;",
			"					G[e.to][e.rev].cap += d;",
			"					return d;",
			"				}",
			"			}",
			"		}",
			"		return 0;",
			"	}",
			"",
			"	T max_flow(int s, int t) {",
			"		// Compute maximum flow via Dinic's algorithm. O(|E||V|^2) in worst case, but faster in many practical cases.",
			"		T flow = 0;",
			"		while (true) {",
			"			bfs(s);",
			"			if (dist[t] < 0) return flow;",
			"			iter.assign(N, 0);",
			"			T f = dfs(s, t, INF);",
			"			while (f > 0) {",
			"				flow += f;",
			"				f = dfs(s, t, INF);",
			"			}",
			"		}",
			"	}",
			"};"
		],
		"description": "Dinic's Max Flow algorithm"
	},
	"min cost flow graph": {
		"prefix": "mcfg",
		"body": [
			"template<typename T>",
			"struct MinCostFlowGraph {",
			"	struct Edge {",
			"		int id;",
			"		int to;",
			"		T cap;",
			"		T cost;",
			"		int rev;",
			"",
			"		Edge(int _id, int _to, T _cap, T _cost, int _rev): id(_id), to(_to), cap(_cap), cost(_cost), rev(_rev) {}",
			"	};",
			"",
			"	T INF = 2e+9;  // TODO: update if needed.",
			"	int N;  // Number of verteces.",
			"	int E;  // Number of edges (excluding the reverse edges for residual).",
			"	vector<vector<Edge>> G;",
			"",
			"	MinCostFlowGraph(int n) {",
			"		N = n;",
			"		E = 0;",
			"		G.resize(N);",
			"	}",
			"",
			"	int add_edge(int from, int to, T cap, T cost) {",
			"		G[from].push_back(Edge(E, to, cap, cost, G[to].size()));",
			"		G[to].push_back(Edge(-1, from, 0, -cost, G[from].size()-1));",
			"		E++;",
			"		return E-1;",
			"	}",
			"",
			"	T min_cost_flow(int s, int t, T f) {",
			"		T res = 0;",
			"		vector<T> h(N, 0), dist(N, INF);",
			"		vector<int> prev_v(N, -1), prev_e(N, -1);",
			"		while (f > 0) {",
			"			// Update potential h[v] by Dijkstra.",
			"			priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> Q;",
			"			dist.assign(N, INF);",
			"			dist[s] = 0;",
			"			Q.push(make_pair(0, s));",
			"			while (!Q.empty()) {",
			"				pair<T, int> p = Q.top();",
			"				Q.pop();",
			"				int v = p.second;",
			"				if (dist[v] < p.first) continue;",
			"				for (int i = 0; i < (int)G[v].size(); i++) {",
			"					Edge &e = G[v][i];",
			"					if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
			"						dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
			"						prev_v[e.to] = v;",
			"						prev_e[e.to] = i;",
			"						Q.push(make_pair(dist[e.to], e.to));",
			"					}",
			"				}",
			"			}",
			"			if (dist[t] == INF) return -1;",
			"			for (int v = 0; v < N; v++) h[v] += dist[v];",
			"",
			"			// Flow along the shortest path s-t.",
			"			T d = f;",
			"			for (int v = t; v != s; v = prev_v[v]) d = min(d, G[prev_v[v]][prev_e[v]].cap);",
			"			f -= d;",
			"			res += d * h[t];",
			"			for (int v = t; v != s; v = prev_v[v]) {",
			"				Edge &e = G[prev_v[v]][prev_e[v]];",
			"				e.cap -= d;",
			"				G[v][e.rev].cap += d;",
			"			}",
			"		}",
			"		return res;",
			"	}",
			"};"
		],
		"decscription": "Minimum Cost Flow algorithm"
	},
	"grid": {
		"prefix": "grid",
		"body": [
			"int H, W;",
			"vector<int> dx{1, -1, 0, 0}, dy{0, 0, 1, -1};",
			"bool is_in(int x, int y) {return 0 <= x && x < H && 0 <= y && y < W;}",
			"int to_int(int x, int y) {return x*W + y;}",
			"pair<int,int> to_xy(int i) {return make_pair(i/W, i%W);}"
		],
		"description": "Grid"
	},
	"rerooting_tree": {
		"prefix": "rt",
		"body": [
			"template <typename Cost, typename Data>",
			"struct RerootingTree {",
			"    template<typename C> struct Edge {",
			"        int to;",
			"        C cost;",
			"",
			"        Edge(int t, C c = 1): to(t), cost(c) {}",
			"    };",
			"    int N;",
			"    vector<vector<Edge<Cost>>> G;",
			"    vector<Data> ans;",
			"    vector<vector<Data>> dp;",
			"",
			"    /* Set variables and functions below depending on the problem! */",
			"    Data identity = 0;    // TODO: Set DP identity data.",
			"    Data leaf() {return 0;}    // TODO: Set DP data for leaf verteces.",
			"    Data merge(Data a, Data b) {return max(a, b);}    // TODO: Set merge function of two DP data.",
			"    Data apply(Data d_pc, int p, int c, Cost cost) {return d_pc + cost;}    // TODO: Set apply function. d_pc:data(dp[p][c]), p:parent, c:child, cost:edge_cost.",
			"    /* Up to here! */",
			"",
			"    RerootingTree(int n) {",
			"        N = n;",
			"        G.resize(n);",
			"    }",
			"",
			"    void add_edge(int u, int v, Cost c = 1) {",
			"        G[u].emplace_back(v, c);",
			"        G[v].emplace_back(u, c);",
			"    }",
			"",
			"    Data dfs1(int v, int par) {",
			"        int degree = G[v].size();",
			"        dp[v].assign(degree, identity);",
			"        Data dp_cum = identity;",
			"        bool updated = false;",
			"        for (int i = 0; i < degree; i++) {",
			"            Edge<Cost> &e = G[v][i];",
			"            if (e.to == par) continue;",
			"            dp[v][i] = dfs1(e.to, v);",
			"            dp_cum = merge(dp_cum, apply(dp[v][i], v, e.to, e.cost));",
			"            updated = true;",
			"        }",
			"        if (updated) return dp_cum;",
			"        else return leaf();",
			"    }",
			"",
			"    void dfs2(int v, Data val, int par) {",
			"        int degree = G[v].size();",
			"        vector<Data> dp_l(degree+1, identity), dp_r(degree+1, identity);",
			"        for (int i = 0; i < degree; i++) {",
			"            Edge<Cost> &e = G[v][i];",
			"            if (e.to == par) dp[v][i] = val;",
			"            dp_l[i+1] = merge(dp_l[i], apply(dp[v][i], v, e.to, e.cost));",
			"        }",
			"        for (int i = degree-1; i >= 0; i--) {",
			"            Edge<Cost> &e = G[v][i];",
			"            dp_r[i] = merge(dp_r[i+1], apply(dp[v][i], v, e.to, e.cost));",
			"        }",
			"        ans[v] = dp_l[degree];",
			"        for (int i = 0; i < degree; i++) {",
			"            Edge<Cost> &e = G[v][i];",
			"            if (e.to != par) dfs2(e.to, merge(dp_l[i], dp_r[i+1]), v);",
			"        }",
			"    }",
			"",
			"    void run() {",
			"        dp.resize(N);",
			"        ans.assign(N, identity);",
			"        dfs1(0, -1);",
			"        dfs2(0, identity, -1);",
			"    }",
			"};"
		],
		"description": "Rerooting Tree DP"
	},
	"mo": {
		"prefix": "mo",
		"body": [
			"template <typename T>",
			"struct Mo {",
			"    struct Query {",
			"        int id, l, r, l_;",
			"        Query(int i, int l, int r, int b = 1): id(i), l(l), r(r) {l_ = l / b;}",
			"    };",
			"",
			"    int N, Q, B;",
			"    vector<Query> queries;",
			"    vector<T> ans;",
			"    int left=0, right=-1;",
			"",
			"    /* Update below! */",
			"    vector<T> state;    // TODO: Set state variables.",
			"    T tmp = 0;    // TODO: Set initial tmp answer.",
			"",
			"    void _add(int a) {",
			"        // TODO: Set add function used in query().",
			"    }",
			"    void _remove(int a) {",
			"        // TODO: Set remove function used in query().",
			"    }",
			"    void _query(Query &q) {",
			"        while (right < q.r) {",
			"            right++;",
			"            _add(A[right]);    // TODO: Update arg.",
			"        }",
			"        while (q.l < left) {",
			"            left--;",
			"            _add(A[left]);    // TODO: Update arg.",
			"        }",
			"        while (left < q.l) {",
			"            _remove(A[left]);    // TODO: Update arg.",
			"            left++;",
			"        }",
			"        while (q.r < right) {",
			"            _remove(A[right]);    // TODO: Update arg.",
			"            right--;",
			"        }",
			"        ans[q.id] = tmp;",
			"    }",
			"    Mo(int n, int q): N(n), Q(q) {",
			"        B = max<int>(1, 1.0 * N / max<double>(1.0, sqrt(Q * 2.0 / 3.0)));",
			"        queries.assign(Q, {0, 0, 0});",
			"        ans.assign(Q, 0);",
			"        state.assign(N, 0);  // TODO: Set state variable.",
			"    }",
			"    /* Up to here! */",
			"",
			"    void add_query(int i, int l, int r) {",
			"        // Add i'th query for [l, r] . (REMARK: closed interval!)",
			"        queries[i] = Query(i, l, r, B);",
			"    }",
			"",
			"    void run() {",
			"        sort(queries.begin(), queries.end(), [](Query &q1, Query &q2){",
			"            if (q1.l_ != q2.l_) return q1.l_ < q2.l_;",
			"            return q1.r < q2.r;",
			"        });",
			"        for (Query &q : queries) _query(q);",
			"    }",
			"};"
		],
		"description": "Mo's algorithm"
	}
}
